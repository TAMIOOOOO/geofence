<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Multi-User Geofence Tracker</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    #map { height: 100vh; width: 100%; }
    .status {
      position: absolute;
      top: 10px; left: 10px;
      background: white; padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      font-weight: bold;
    }
  </style>
</head>
<body>

<div id="map"></div>
<div class="status" id="status">Connecting...</div>

<script>
// --- CONFIGURATION ---
const geofenceCenter = [14.380439456531477, 120.87314190182668];
const geofenceRadius = 100; // meters
const userId = "User-" + Math.floor(Math.random() * 10000);

// --- MAP INITIALIZATION ---
const map = L.map('map').setView(geofenceCenter, 17);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

// Draw geofence
const circle = L.circle(geofenceCenter, {
  radius: geofenceRadius,
  color: 'blue',
  fillColor: '#3f83f8',
  fillOpacity: 0.3
}).addTo(map);
L.marker(geofenceCenter).addTo(map).bindPopup("Geofence Center");

// --- SOCKET CONNECTION ---
const socket = io();
const markers = {}; // store user markers

// --- HELPER FUNCTION: Haversine Distance ---
function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3;
  const Ï†1 = lat1 * Math.PI/180;
  const Ï†2 = lat2 * Math.PI/180;
  const Î”Ï† = (lat2 - lat1) * Math.PI/180;
  const Î”Î» = (lon2 - lon1) * Math.PI/180;
  const a = Math.sin(Î”Ï†/2)**2 + Math.cos(Ï†1)*Math.cos(Ï†2)*Math.sin(Î”Î»/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// --- GEOLOCATION WATCH ---
if (navigator.geolocation) {
  navigator.geolocation.watchPosition(pos => {
    const lat = pos.coords.latitude;
    const lon = pos.coords.longitude;
    const accuracy = pos.coords.accuracy;

    // Send current location to server
    socket.emit('updateLocation', {
      id: userId,
      lat: lat,
      lon: lon,
      accuracy: accuracy
    });

  }, err => alert("Location error: " + err.message),
  { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 });
} else {
  alert("Geolocation not supported.");
}

// --- RECEIVE OTHER USERS' LOCATIONS ---
socket.on('userLocationUpdate', data => {
  const { id, lat, lon, accuracy } = data;

  // Calculate inside/outside
  const distance = getDistance(lat, lon, geofenceCenter[0], geofenceCenter[1]);
  const inside = distance <= geofenceRadius;

  // Add or update marker
  if (!markers[id]) {
    markers[id] = L.marker([lat, lon]).addTo(map);
  } else {
    markers[id].setLatLng([lat, lon]);
  }

  // Popup text
  markers[id].bindPopup(`${id}<br>ğŸ“ ${inside ? 'âœ… Inside' : 'âŒ Outside'}<br>ğŸ“ ${distance.toFixed(1)} m`);
  
  // If this is you, update status
  if (id === userId) {
    const status = document.getElementById('status');
    status.innerHTML = inside
      ? `âœ… Inside Geofence<br>Distance: ${distance.toFixed(1)} m<br>Accuracy: ${accuracy.toFixed(1)} m`
      : `âŒ Outside Geofence<br>Distance: ${distance.toFixed(1)} m<br>Accuracy: ${accuracy.toFixed(1)} m`;
    status.style.background = inside ? "#a7f3d0" : "#fecaca";
  }
});

// --- REMOVE MARKER WHEN USER DISCONNECTS ---
socket.on('userDisconnected', id => {
  if (markers[id]) {
    map.removeLayer(markers[id]);
    delete markers[id];
  }
});
</script>
</body>
</html>
